import Camera_Manager
from pathlib import Path
import cv2 as cv
import pi_debugging as debug
import numpy as np
import matplotlib.pyplot as plt


def siftMatching(cam):
    # Initiate ORB detector
    orb = cv.ORB_create()

    ret, img1 = cam.read()
    while ret:
        ret, img2 = cam.read()
        imgGray1 = cv.cvtColor(img1, cv.COLOR_BGR2GRAY)
        imgGray2 = cv.cvtColor(img2, cv.COLOR_BGR2GRAY)

        # find the keypoints and descriptors with ORB
        kp1, des1 = orb.detectAndCompute(imgGray1,None)
        kp2, des2 = orb.detectAndCompute(imgGray2,None)

        # create BFMatcher object
        bf = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=True)
        # Match descriptors.
        matches = bf.match(des1,des2)
        # Sort them in the order of their distance.
        matches = sorted(matches, key = lambda x:x.distance)

        # Draw first 10 matches.
        img3 = cv.drawMatches(
            img1,kp1,img2,kp2,matches,
            None,
            flags=cv.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS
        )
        plt.imshow(img3)
        plt.show()

        img1 = img2.copy()

def main():
    imgPath = Path("Chessboard_detection", "TestImages", "03_03_2023", "4")

    cam = Camera_Manager.FakeCamera((480, 640), str(imgPath.resolve()))

    patternSize = (7, 5)

    _, img = cam.read()
    img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)

    img1 = cv.adaptiveThreshold(
        img,
        255,
        cv.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv.THRESH_BINARY,
        121,
        2
    )
    retVal, corners = cv.findChessboardCornersSB(img1, patternSize)
    
    print(retVal)
    
    # if retVal:
    cv.drawChessboardCorners(img, patternSize, corners, retVal)
    debug.showImg([img, img1])
        # corners = cv.cornerSubPix(img, corners)

if __name__ == "__main__":
    main()